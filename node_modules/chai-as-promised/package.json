{
  "name": "chai-as-promised",
  "description": "Extends Chai with assertions about promises.",
  "keywords": [
    "chai",
    "testing",
    "promises"
  ],
  "version": "3.2.3",
  "author": {
    "name": "Domenic Denicola",
    "email": "domenic@domenicdenicola.com",
    "url": "http://domenicdenicola.com"
  },
  "license": "WTFPL",
  "repository": {
    "type": "git",
    "url": "git://github.com/domenic/chai-as-promised.git"
  },
  "bugs": {
    "url": "http://github.com/domenic/chai-as-promised/issues"
  },
  "directories": {
    "lib": "./lib"
  },
  "main": "./lib/chai-as-promised.js",
  "scripts": {
    "test": "mocha",
    "test-browser-q": "coffee ./test/browser/runner q",
    "test-browser-when": "coffee ./test/browser/runner when",
    "lint": "jshint ./lib",
    "cover": "cover run node_modules/mocha/bin/_mocha && cover report html && opener ./cover_html/index.html"
  },
  "devDependencies": {
    "chai": ">= 1.3.0",
    "coffee-script": ">= 1.4.0",
    "cover": ">= 0.2.8",
    "ecstatic": ">= 0.1.6",
    "glob": ">= 3.1.14",
    "jshint": ">= 0.9.1",
    "mocha": ">= 1.6.0",
    "opener": ">= 1.3.0",
    "q": ">= 0.8.9",
    "underscore": ">= 1.4.2"
  },
  "readme": "Chai Assertions for Working with Promises\r\n=========================================\r\n\r\n**Chai as Promised** extends [Chai][chai] with a fluent language for asserting facts about [promises][presentation].\r\n\r\nInstead of manually wiring up your expectations to a promise's fulfilled and rejected handlers:\r\n\r\n```javascript\r\ndoSomethingAsync().then(\r\n    function (result) {\r\n        result.should.equal(\"foo\");\r\n        done();\r\n    },\r\n    function (err) {\r\n       done(err);\r\n    }\r\n);\r\n```\r\n\r\nyou can write code that expresses what you really mean:\r\n\r\n```javascript\r\ndoSomethingAsync().should.eventually.equal(\"foo\").notify(done);\r\n```\r\n\r\nor if you have a testing framework that follows the [UncommonJS specification][uncommonjs] for handling promises,\r\nsimply\r\n\r\n```javascript\r\nreturn doSomethingAsync().should.eventually.equal(\"foo\");\r\n```\r\n\r\n## How to Use\r\n\r\n### `should`/`expect` Interface\r\n\r\nThe most powerful extension provided by Chai as Promised is the `eventually` property. With it, you can transform any\r\nexisting Chai assertion into one that acts on a promise:\r\n\r\n```javascript\r\n(2 + 2).should.equal(4);\r\n\r\n// becomes\r\nreturn promiseFor(2 + 2).should.eventually.equal(4);\r\n\r\n\r\nexpect({ foo: \"bar\" }).to.have.property(\"foo\");\r\n\r\n// becomes\r\nreturn expect(promiseFor({ foo: \"bar\" })).to.eventually.have.property(\"foo\");\r\n```\r\n\r\nThere are also a few promise-specific extensions, grouped here as synonymic blocks (with the usual `expect`\r\nequivalents):\r\n\r\n```javascript\r\nreturn promise.should.be.fulfilled;\r\n\r\nreturn promise.should.eventually.eql(\"foo\");\r\nreturn promise.should.become(\"foo\");\r\n\r\nreturn promise.should.be.rejected;\r\nreturn promise.should.be.broken;\r\n\r\nreturn promise.should.be.rejected.with(Error);\r\nreturn promise.should.be.broken.with(Error);\r\n\r\n// Note: other variants of Chai's existing `throw` assertion work too.\r\n```\r\n\r\n### `assert` Interface\r\n\r\nAs with the `should`/`expect` interface, Chai as Promised provides an `eventually` extender to `chai.assert`, allowing\r\nany existing Chai assertion to be used on a promise:\r\n\r\n```javascript\r\nassert.equal(2 + 2, 4, \"This had better be true\");\r\n\r\n// becomes\r\nreturn assert.eventually.equal(promiseFor(2 + 2), 4, \"This had better be true, eventually\");\r\n```\r\n\r\nAnd there are, of course, promise-specific extensions:\r\n\r\n```javascript\r\nreturn assert.isFulfilled(promise, \"optional message\");\r\n\r\nreturn assert.eventually.deepEqual(promise, \"foo\", \"optional message\");\r\nreturn assert.becomes(promise, \"foo\", \"optional message\");\r\n\r\nreturn assert.eventually.notDeepEqual(promise, \"foo\", \"optional message\");\r\nreturn assert.doesNotBecome(promise, \"foo\", \"optional message\");\r\n\r\nreturn assert.isRejected(promise, \"optional message\");\r\nreturn assert.isBroken(promise, \"optional message\");\r\n\r\nreturn assert.isRejected(promise, Error, \"optional message\");\r\nreturn assert.isBroken(promise, Error, \"optional message\");\r\n\r\nreturn assert.isRejected(promise, /error message matcher/, \"optional message\");\r\nreturn assert.isBroken(promise, /error message matcher/, \"optional message\");\r\n```\r\n\r\n### Progress Callbacks\r\n\r\nChai as Promised does not have any intrinsic support for testing promise progress callbacks. The properties you would\r\nwant to test are probably much better suited to a library like [Sinon.JS][sinon], perhaps in conjunction with\r\n[Sinon–Chai][sinon-chai]:\r\n\r\n```javascript\r\nvar progressSpy = sinon.spy();\r\n\r\nreturn promise.then(null, null, progressSpy).then(function () {\r\n    progressSpy.should.have.been.calledWith(\"33%\");\r\n    progressSpy.should.have.been.calledWith(\"67%\");\r\n    progressSpy.should.have.been.calledThrice;\r\n});\r\n```\r\n\r\n### Working with Non-Promise–Friendly Test Runners\r\n\r\nAs mentioned, many test runners (\\*cough\\* [Mocha][mocha-makes-me-sad] \\*cough\\* … but see [Mocha as Promised][]!)\r\ndon't support the nice `return` style shown above. Instead, they take a callback indicating when the asynchronous test\r\nrun is over. Chai as Promised adapts to this situation with the `notify` method, like so:\r\n\r\n```javascript\r\nit(\"should be fulfilled\", function (done) {\r\n    promise.should.be.fulfilled.and.notify(done);\r\n});\r\n\r\nit(\"should be rejected\", function (done) {\r\n    otherPromise.should.be.rejected.and.notify(done);\r\n});\r\n```\r\n\r\nIn these examples, if the conditions are not met, the test runner will receive an error of the form `\"expected promise\r\nto be fulfilled but it was rejected with [Error: error message]\"`, or `\"expected promise to be rejected but it was\r\nfulfilled.\"`\r\n\r\nThere's another form of `notify` which is useful in certain situations, like doing assertions after a promise is\r\ncomplete. For example:\r\n\r\n```javascript\r\nit(\"should change the state\", function (done) {\r\n    otherState.should.equal(\"before\");\r\n    promise.should.be.fulfilled.then(function () {\r\n        otherState.should.equal(\"after\");\r\n    }).should.notify(done);\r\n});\r\n```\r\n\r\nNotice how `.notify(done)` is hanging directly off of `.should`, instead of appearing after a promise assertion. This\r\nindicates to Chai as Promised that it should pass fulfillment or rejection directly through to the testing framework.\r\nThus, the above code will fail with a Chai as Promised error (`\"expected promise to be fulfilled…\"`) if `promise` is\r\nrejected, but will fail with a simple Chai error (`expected \"before\" to equal \"after\"`) if `otherState` does not change.\r\n\r\nAnother example of where this can be useful is when performing assertions on multiple promises:\r\n\r\n```javascript\r\nit(\"should all be well\", function (done) {\r\n    Q.all([\r\n        promiseA.should.become(\"happy\"),\r\n        promiseB.should.eventually.have.property(\"fun times\"),\r\n        promiseC.should.be.rejected.with(TypeError, \"only joyful types are allowed\")\r\n    ]).should.notify(done);\r\n});\r\n```\r\n\r\nThis will pass any failures of the individual promise assertions up to the test framework, instead of wrapping them in\r\nan `\"expected promise to be fulfilled…\"` message as would happen if you did\r\n`Q.all([…]).should.be.fulfilled.and.notify(done)`.\r\n\r\n## Installation and Setup\r\n\r\n### Node\r\n\r\nDo an `npm install chai-as-promised` to get up and running. Then:\r\n\r\n```javascript\r\nvar chai = require(\"chai\");\r\nvar chaiAsPromised = require(\"chai-as-promised\");\r\n\r\nchai.use(chaiAsPromised);\r\n```\r\n\r\nYou can of course put this code in a common test fixture file; for an example using [Mocha][mocha], see\r\n[the Chai as Promised tests themselves][fixturedemo].\r\n\r\n### AMD\r\n\r\nChai as Promised supports being used as an [AMD][amd] module, registering itself anonymously (just like Chai). So,\r\nassuming you have configured your loader to map the Chai and Chai as Promised files to the respective module IDs\r\n`\"chai\"` and `\"chai-as-promised\"`, you can use them as follows:\r\n\r\n```javascript\r\ndefine(function (require, exports, module) {\r\n    var chai = require(\"chai\");\r\n    var chaiAsPromised = require(\"chai-as-promised\");\r\n\r\n    chai.use(chaiAsPromised);\r\n});\r\n```\r\n\r\n### `<script>` tag\r\n\r\nIf you include Chai as Promised directly with a `<script>` tag, after the one for Chai itself, then it will\r\nautomatically plug in to Chai and be ready for use:\r\n\r\n```html\r\n<script src=\"chai.js\"></script>\r\n<script src=\"chai-as-promised.js\"></script>\r\n```\r\n\r\n\r\n[presentation]: http://www.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript\r\n[chai]: http://chaijs.com/\r\n[mocha]: http://visionmedia.github.com/mocha/\r\n[mocha-makes-me-sad]: https://github.com/visionmedia/mocha/pull/329\r\n[Mocha as Promised]: https://github.com/domenic/mocha-as-promised\r\n[uncommonjs]: http://kriskowal.github.com/uncommonjs/tests/specification\r\n[fixturedemo]: https://github.com/domenic/chai-as-promised/tree/master/test/\r\n[amd]: https://github.com/amdjs/amdjs-api/wiki/AMD\r\n[sinon]: http://sinonjs.org/\r\n[sinon-chai]: https://github.com/domenic/sinon-chai\r\n",
  "_id": "chai-as-promised@3.2.3",
  "dist": {
    "shasum": "4cb6d7a4993f4d9e7f0465eaae0d2e427ea541f6"
  },
  "_from": "chai-as-promised"
}
